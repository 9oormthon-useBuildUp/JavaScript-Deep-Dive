# 12장 함수

- 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- `매개 변수`: 함수 내부로 입력을 전달받는 변수
- `인수`: 함수에 전달되는 입력
- `반환값`: 출력값
- 함수는 객체이다.

## 함수의 정의
- 함수는 **함수 정의**를 통해 생성한다.
``` javascript
function add(x, y){
    return x + y;
}
```

## 함수 호출

- 함수를 정의했다고 호출 되는 것이 아니라, 인수를 매개변수를 통해 함수에 전달하며 함수의 실행을 명시적으로 지시해줘야 함수가 실행된다.

```javascript
// 함수 호출
var result = add(2, 5);

// 반환값 출력
console.log(result);
```
## 함수를 사용하는 이유
- 함수는 한 번 만들어두면 필요할 때 여러 번 **재사용이 가능**하다.
- 동일한 작업을 반복적으로 수행해야 한다면 코드 중복을 제거할 수 있다.
- 코드 **유지보수의 편의성**이 높아진다.
- 실수를 줄여서 **코드의 신뢰성**을 높일 수 있다.
- 함수는 객체 타입의 값이므로 식별자를 붙일 수 있는데, 이 식별자를 통해 함수의 내부 코드를 이해하지 않아도 함수의 역할을 파악할 수 있다. 따라서 **코드의 가독성**이 향상된다.

## 함수의 리터럴
```javascript
var f = function add(x, y){
    return x + y;
}
```
- 변수에 함수 리터럴을 할당하고 있다.

### **함수 리터럴의 구성요소**

구성요소|설명
|---|---|
|함수 이름|- 함수 이름은 **식별자**다. 식별자 네이밍 규칙을 준수해야 한다.<br>- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.<br>- 함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명 함수라 한다.|
|매개변수 목록|- 0개 이상의 매개변수를 소괄호로 감싸고 `쉼표`로 구분한다. <br> - 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다. <br> - 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 식별자 네이밍 규칙을 준수해야 한다.|
|함수 몸체| - 함수가 호출되었을 떄 일괄적으로 실행된 문들을 하나의 실행단위로 정의한 코드 블록이다. <br> - 함수 몸체는 함수 호출에 의해 실행된다.|

함수는 객체인데, 일반 객체와는 조금 달라서 호출도 가능하다.

## 함수 정의
- 함수 정의: 호출 전에 매개변수, 반환할 값을 지정하는 것

### 함수 정의 방법
#### 1. 함수 선언문

```javascript
function add(x, y){
    return x + y;
}
```
- 함수 선언문은 함수 리터럴과 형태가 동일하다. 단 함수 선언문은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.
- 함수 선언문은 표현식이 아닌 문이다.
- 자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성하는데, 이 때 함수를 호출하기 위해 **함수 이름과 동일한 이름의 식별자를 암묵적으로 생성**하고, 거기에 함수 객체를 할당한다.
- 함수 선언문의 경우 **런타임 이전**에 함수 객체를 생성한다. 따라서 선언 코드보다 상단에서 함수를 호출하는 것이 가능하다. **(호이스팅)**

#### 2. 함수 표현식
- 함수 리터럴이 값으로 평가되어야 하는 문맥이면 자바스크립트 엔진은 함수 리터럴 표현식으로 해석한다.
- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이기 때문에, 식별자에 함수 객체의 주소가 저장돼 있어야 하고 그 식별자로 함수를 호출해야 한다.
- 아래처럼 함수 리터럴의 함수 이름을 생략하는 것이 일반적이다.
- 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 **변수 호이스팅**이 발생한다. 따라서 식별자에 `undefined`가 저장된다. 따라서 함수 호출은 함수 정의 이후에 사용해야 한다.
```javascript
var add = function (x, y) {
    return x + y;
}
```

#### 3. Function 생성자 함수
```javascript
var add = new Function('x', 'y', 'return x + y');
```
- `Function`은 자바스크립트가 기본 제공하는 빌트인 함수이다.
- `Function` 생성자 함수에 매개변수와 함수 몸체를 문자열로 전달하면서 `new` 연산자와 함꼐 호출하면 함수 객체를 생성해서 반환한다.
- 일반적이지 않은 방식이며, 바람직하지 않다.
- 함수 선언문/ 함수 표현식으로 생성한 함수와 다르게 동작함!

#### 4. 화살표 함수(ES6)

```javascript
var add = (x, y) => x + y;
```

- ES6에서 도입된 함수이다.
- `function` 키워드 대신 **화살표(=>)**를 사용해 좀 더 간략하게 함수를 선언하는 방법이다.

## 함수 호출
- 함수를 가리키는 **식별자**와 한 쌍인 소괄호 **함수 호출 연산자**를 사용하여 호출한다.
- 함수 호출 연산자 내에 0개 이상의 인수를 쉼표로 구분해서 나열한다.

### 매개변수와 인덱스
- 함수 외부에서 함수 내부로 값(인수)를 전달할 떄는 **매개변수(인자)** 를 통해 전달한다.
- 인수는 값으로 평가될 수 있는 **표현식**이어야 한다.
- 매개변수의 스코프는 **함수 내부**이다. -> 외부에서는 참조할 수 없다!
- 매개변수의 개수와 인수의 개수가 일치하지 않는 경우, 인수가 더 많으면 초과된 인수는 무시하며, 인수가 적은 경우 할당되지 않은 매개변수의 값은 `undefined`가 된다.
- 초과된 인수도 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

### 인수 확인
- 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
- 자바스크립트는 동적 타입 언어이므로 매개변수의 타입을 사전에 지정할 수 없다

=> 그래서 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다!!!
- 단축평가를 통해 `undefined`인 매개 변수에 초기값을 줄 수도 있다.
- ES6에서 도입된 **매개변수 기본값**을 사용하여 함수 내애세 수행하던 인수 체크/ 초기화를 간소화할 수 있다. -> 인수가 전달되지 않은 경우나 undefined를 전달한 경우 이 매개변수 기본값이 사용된다.

### 매개변수의 최대 개수
- 이상적인 매개변수 개수는 0개이며, 적을 수록 좋다.
    - 매개변수가 많다는 것은 함수가 여러 일을 한다는 증거이므로 바람직하지 않다.
    - **이상적인 함수는 한 가지 일만 해야 하며, 가급적 작게 만들어야 한다.**
- 명시적으로 제한하고 있진 않지만 **최대 3개** 이상 넘지 않을 것을 권장한다.

### 반환문
- 반환문은 생략이 가능하며, 없는 경우 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.
- return 키워드와 반환값 사이에 줄바꿈이 있으며 세미콜론 자동 삽입 기능에 의해 반환값이 무시되고 암묵적으로 undefined가 반환될 수 있다.
- 반환문은 함수 몸체 내부에서만 사용할 수 있다. 전역에서 반환문을 사용하면 문법에러가 발생한다.

### 참조에 의한 전달과 외부 상태의 변경
- 인수로 객체 타입이 들어오는 경우 참조값이 복사되어 매개변수로 전달되기 때문에, 참조값을 통해 객체의 프로퍼티를 변경하는 경우 **원본이 훼손된다**. (부수효과!)
- 이 문제를 해결하기 위해 객체를 **불변 객체**로 만들어 사용한다.
    - 객체를 마치 원시 값처럼 벼경 불가능한 값으로 동작하게 만드는 방법이다.

## 다양한 함수의 형태

### 즉시 실행 함수
- **함수 정의와 동시에 즉시 호출**되는 함수이다.
- 단 한 번만 호출되며 **다시 호출할 수 없다**.
- 이름이 없는 익명함수를 사용하는 것이 일반적이다.
- 즉시 실행 함수는 **반드시 그룹 연산자 (...)로 감싸야 한다**.
    -> 함수 선언문은 함수의 이름을 생략할 수가 없다.

```javascript
(function(){
    var a = 5;
    var b = 4;
    return a * b;
}());
```

### 재귀함수
- 함수가 **자기 자신을 호출**하는 것을 재귀 호출이라고 한다.
- 재귀함수는 **반복되는 처리**를 사용하기 위해 사용한다.
- 재귀 함수에는 반드시 **탈출 조건**이 있어야 한다.
- 재귀함수는 모두 for나 while로 바꿀 수 있다. 
    -  반복문은 일반적으로 성능이 더 좋고, 재귀의 오버헤드를 피할 수 있다는 장점을 갖는다.
    - 재귀는 코드가 더 간결하고 이해하기 쉬운 경우가 많다는 장점을 갖는다.
- 무한 반복으로 인한 스택 오버플로 에러를 발생시킬 수 있기 때문에, 재귀함수의 사용이 반복문보다 직관적으로 이해하기 쉬울 때에만 한정적으로 사용하는 것이 바람직하다.


### 중첩 함수
- 함수 내부에 정의된 함수를 **중첩 함수** 또는 **내부 함수**라고 한다.
- 중첩 함수를 포함하는 함수는 **외부 함수**라고 부른다.
- 중첩 함수는 보통 외부 함수를 돕는 **헬퍼 함수**의 역할을 한다.

```javascript
function outer() {
    var x = 1;

    function inner() {
        var y = 2;
        console.log(x + y); // 3
    }

    inner();
}

outer();
```

### 콜백 함수 

- 함수의 **매개변수를 통해 다른 함수의 내부로 전달되는 함수**를 `콜백함수`라고 한다.
- 콜백함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.
- 매개변수를 통해 함수의 외부에서 콜백함수를 전달받는 함수는 고차함수라고 한다.
- 공통적으로 수행하는 부분이 있고, 함수의 일부분만 다른 경우 함수를 합성하는 것으로 해결할 수 있다.
    - 함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 함수 내부로 전달할 수 있다. 
    - 이 때, 고차 함수는 콜백함수를 자신의 일부분으로 합성한다.
- 자바스크립트의 함수는 일급 객체이므로 함수의 매개변수를 통해 함수를 전달할 수 있다.

### 순수 함수와 비순수 함수 

- 순수 함수: 어떤 외부 상태에 의존하지도 않고, 변경하지도 않는, 즉 **부수 효과가 없는 함수**를 의미한다.
    - 최소 하나 이상의 인수를 전달 받는다.
    - 인수의 불변성을 유지한다.
- 비순수 함수: 외부 상태에 의존하거나, 외부 상태를 변경하는, 즉 **부수효과가 있는 함수**를 의미한다.
    - 외부 상태에 따라 반환값이 달라진다.

- 함수의 외부 상태를 변경하면 상태 변화의 추적이 어려워진다.
- 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다.
- 비순수 함수는 코드의 복잡성을 증가시킨다.